# Emaily - A fullstack project built by React/Redux and Node.js
## *This project is a feedback collection application faced for start-up owner/product manager so that they can collect feedbacks from their own individual users.*

### Teches used in this project:
1. FrontEnd: React/Redux (Redux form).
2. BackEnd Server: Node/Express.
3. Database: MongoDB.
4. Authetication: Google OAuth + Passport JS.
5. Handling Billings: Stripe.
6. Email Provider: SendGrid.
7. Deploy: Heroku.

### Belows are some keypoints that I learned from this emaily project:
* Express/Node API serves as messager between React App (send out HTTP request) and MongoDB.
* `package.json` is a control hub of our project that can be used to define a lot of different dependencies that our project depends upon.
* Node: execute code outside of the brower.
* Express: a library runs in Node runtime that has a collection of helper methods which makes dealing with HTTP traffic requests came from React App easier.
* The incoming HTTP traffic from React App will rush in some port of Node where the Express will use Route Handler to give according responce to Node and up to React App.
* In Node.js, we can not use ES2015 module like *import express from 'express'*, instead, the correct way is *const express = require('express')*.
* Heroku is used to deploy this project, finally, it will return a URL for this project where anyone else can use this URL to use our application instead of *http://localhost:3000* which is only visable for our own local machine.
* If there are some variables that we do not want other engineers to change it, we should name it full capticalize : e.x. CONSTVARIABLE
* Passport JS is used to help OAuth (Google, Facebook, Twitter...) easier. However, it still has some cons: 1. not all automatic. 2. So hard for the user to have a bigger picture about what is going on by just adding some weired code here and there. 3. Need to download multiple passport strategy for mutiple specific provider(Google, Facebook...).
* In OAuth, client ID is for public while clientSecret is private and not for sharing. So, we can store it inside a file like `config/key.js` that will not be pulled up to Github by using `.gitignore`.
* Inside the helper OAuth Strategy function: GoogleStrategy({clientID, clientSecret, callbackURL}, () => {}): the callback URL is used for redirecting the user after getting their permission to let google provides their informations (However, this URL must be set to authorized redirect URLs beforehead to avoid "Error: redirect_uri_mismatch in Google OAuth website"). As for the () => {} arrow function: it is called after the server exchange the code with the Google server and get the users' info. So, inside this arrow function, we should take the autheticated user info and save it into the database (MongoDB) by *new User({id:XXX}).save()*. But remeber, we should search our database first to see whether the user already exist (then we can skip this step).
* Node mon is a helper library that can automatically restart the backend server everytime we changed our source code so that we do not need to restart manually.
* After refactor and spread all elements, we must wire them back into `index.js`(used to boost up everything), otherwise they will not be  excuated automatically.
* Cookies, unlike stateless HTTP, can be relied on for unique identifing information exchanged between browser and server. After the user logs out, the cookie will be unset.
* We use the unique and consistent profile id in OAuth as the unique email-password for authetication. It is the only thing we care about after all those Google OAuth Flow.
* The MongoDB used in this project is hosted by MongoDB Atlas. In MongoDB, mongoose.js is a helper library. Belows are some correspondences between MongoDB world and mongoose world: Collections <=> Model class; {id: 1, name: "Alex", age: 30} <=> Model Instance.
* To include helper function Schema inside mongoose, we can use ES2015 destructing: const {Schema} = mongoose
* For referring mongoose models, we do not write *require()*, instead, we call it directly by *const user = mongoose.model('user')*.
* In `index.js`, *require('./models/User')* (define the Mongo) should be put in front of *require('./services/passport')* (implement the Mongo).
* *.then()* is used as callback for async operation (every operations on database).
* By passing to the serialUser(), the user model generated by the arrow callback function in GoogleStrategy will be transformed into some identifying pieces of information. Then the Passport.JS will take these information and transform them into the cookie and pass the cookie to the browser. After this flow, later on, once the user make any request, the cookie will be passed into the server and being processed by deserialUser() for identifying which user/user model it is.
* OAuth's only purpose is to allow someone to sign in/log in, after that, we will use our own internal ID assigned by MongoDB instead of the Google profile ID.
* cookie-session helper library is used for managing cookies.
* Inside the passing in arguments (req, res) for backend, Passport.JS automatically attaches the user property and many other helper function like req.logout() (after this, req.user() will become null) to the req object.
* Inside `config/keys`, we need to develop two set of keys: dev (inside laptop) and prod (inside Heroku) for mainly 3 reasons: 1. In case the laptop is losted or hacked; 2. For creating a neww and clear MongoDB; 3. In this way, we can do development without affect the real product. In order to do this, we need to create a new set of keys (MongoDB keys, Google API keys, cookie keys...) and set them inside Heroku config variables so that they can pulled by *process.env* later on.
* Since the *process.env.NODE_ENV* can decide whether the current mode is development production, so we can use it as the condition logic inside `key.js`.
* By setting *Proxy: true*, we can tells GoogleStrategy to trust any middle proxy (like Heroku proxy) so that the original setted "https" will not be changed into "http" for the callback URL.
* Compared to "http", "https" is used for entering the sensitive information like credit card information because if we put those information in "http" (the extra "s" here means security), everyone else can see.
* React (client) has a separate front-end server (generate JS stuff) rather than the node/express server (generate Json data). The reason we use two separate servers is because once combined them into a single server, we cannot use create-react-app which has many built-in great helper libraries.
* After adding *"dev": "concurrently \"npm run server\" \"npm run client\""* under the `package.json` under `server`, we can start two servers together by running npm run dev in the terminal.
* After adding *proxy: {"/auth/google": {"target": "http://localhost:5000"}}* under the `package.json` under `client`, we can refer to *auth/google* even if we are in our front-end URL (localhost:3000), this addition line of code will magically connect with the backend server and take us to localhost:5000/auth/google, the proxy here is a built-in proxy in create-react-app for communicating with the backend Node/Express API server.
* However, in production mode, there is no create-react-app server (only be created in the dev mode for us to have a good experience in creating react), only the Node/Express server will existed for serveing all the react part, also, the *auth/google* will definitely work since we are now only at backend URL provided by Heroku.
* Async request (like operations on database) will return a promise, and *.then()* is used as callback function that will be automatically called with the value returned from the async requests.
* Rather than the *.then()*, we can also applied a more understandable way: Async/Await consisted of mainly two steps: 1. put "async" ahead of function contains any async code; 2. put "await" ahead of the promise and assign it to some const variables that we can use later on.
* In React world, there are two root files: `index.js` (boost up logic for Redux) and `App.js` (React layer where decide which components to show using React Router).
* Naming strategy: If the file will export some react components, we need capitalizate at the beginning like `App.js`, otherwise, if the file only exports a function, switch to lowercase opening like `functionX.js`.
* Provider inside the `index.js` is a react component come from react-redux library that makes the redux store accessible for every components under `App.js`.
* In action creators, we can communicate between the frontend React/Redux to Node/Express API by making a URL request by axios to backend URLs. After this, we can use the response from Node/Express API to update the states in redux store with the help of redux-thunk which helps to fix problems caused by async response by having direct access to the dispatch().
* In order to let every components have the ability to get access to the auth states, the auth action creator is put inside the componentDidMount() life cycle method in the App component in `App.js` by connect().
* There are two methods for logging out: 1. Use full http request by link tage 《a》《/a》
